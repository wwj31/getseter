package main

import (
	"flag"
	"fmt"
	"go/ast"
	"log"
	"os"
	"path/filepath"
	"strings"

	"golang.org/x/tools/go/packages"
)

var (
	typeNames = flag.String("type", "", "gennerate type ")
	seter     = flag.Bool("set", false, "provide set fun of attribute")
)

func main() {
	flag.Usage = func() { fmt.Println("type error") }
	flag.Parse()
	if len(*typeNames) == 0 {
		flag.Usage()
		os.Exit(2)
	}

	types := strings.Split(*typeNames, ",")
	for _, typ := range types {
		genFile(typ)
	}
}
func genFile(typ string) {
	var (
		packName         string
		valName,valType,getModify []string
	)
	pack := parsePackage(nil, nil)
	for _, astFile := range pack.Syntax {
		for name, _ := range astFile.Scope.Objects {
			if name == typ {
				packName = astFile.Name.Name
				valName, valType,getModify = inspectAST(astFile, name)
				goto result
			}
		}
	}

result:
	outputName := filepath.Join("./", strings.ToLower(fmt.Sprintf("attr_%s.go", typ)))
	outfile(outputName, packName, typ, valName, valType, getModify)
}

// parsePackage analyzes the single package constructed from the patterns and tags.
func parsePackage(patterns []string, tags []string) *packages.Package {
	cfg := &packages.Config{
		Mode:       packages.NeedTypes | packages.NeedSyntax | packages.NeedTypesInfo,
		Tests:      false,
		BuildFlags: []string{fmt.Sprintf("-tags=%s", strings.Join(tags, " "))},
	}
	pkgs, err := packages.Load(cfg, patterns...)
	if err != nil {
		log.Fatal(err)
	}
	if len(pkgs) != 1 {
		log.Fatalf("error: %d packages found", len(pkgs))
	}
	return pkgs[0]
}

func inspectAST(file *ast.File, typeName string) (valName, valType,valGetModify []string) {
	var name string
	// Inspect the AST and print all identifiers and literals.
	ast.Inspect(file, func(n ast.Node) bool {
		switch x := n.(type) {
		case *ast.Ident:
			name = x.Name
		case *ast.StructType:
			if name == typeName {
				for _, field := range x.Fields.List {
					if len(field.Names) > 0 {
						valName = append(valName, field.Names[0].Name)
					} else if v, ok := field.Type.(*ast.Ident); ok {
						valName = append(valName, v.Name)
					}

					var bmap bool
					v,bptr := switchPtrAndVal(field.Type)
					if v != ""{
						valType = append(valType,v)
					}else{
						switch x := field.Type.(type) {
						case *ast.BasicLit:
							valType = append(valType, x.Value)
						case *ast.MapType:
							key, _ := x.Key.(*ast.Ident)
							val,_ := switchPtrAndVal(x.Value)
							valType = append(valType, fmt.Sprintf("map[%v]%v", key, val))
							bmap = true
						case *ast.ArrayType:
							val,_ := switchPtrAndVal(x.Elt)
							valType = append(valType, fmt.Sprintf("[]%v", val))
						}
					}

					if *seter && (bptr || bmap) {
						valGetModify = append(valGetModify,tplgetmodify)
					}else{
						valGetModify = append(valGetModify,"")
					}
				}
				return false
			}
		}
		return true
	})
	if len(valName) != len(valType) {
		return nil, nil,nil
	}
	return valName, valType,valGetModify
}

const tplpackage = `{comment}
package {package}

`

const tplgetmodify = `s.bool = true;`

const tplget = `
func (s *{receiver}) {funname}() {return} { {modify} return s.{val} }
`

const tplset = `func (s *{receiver}) Set{funname}(v {input}) { {modify} s.{val} = v }
`

func outfile(output, packagename, struname string, valname, valtype, getmodify []string) {
	_ = os.Remove(output)
	file, err := os.Create(output)
	if err != nil {
		log.Fatalf("error: %v outfile", err)
	}
	context := strings.NewReplacer([]string{
		"{comment}", fmt.Sprintf("// Code generated by \"stringer %s\"; DO NOT EDIT.\n", strings.Join(os.Args[1:], " ")),
		"{package}", packagename,
	}...).Replace(tplpackage)

	for i, val := range valname {
		r := rune(val[0])
		if r < 97 {
			continue
		}
		typ := valtype[i]
		modify := getmodify[i]

		// provide get func
		context += strings.NewReplacer([]string{
			"{receiver}", struname,
			"{funname}", strFirstToUpper(val),
			"{return}", typ,
			"{val}", val,
			"{modify}",modify,
		}...).Replace(tplget)

		if *seter && val != "bool" && modify == ""{
			// provide set func
			context += strings.NewReplacer([]string{
				"{receiver}", struname,
				"{funname}", strFirstToUpper(val),
				"{input}", typ,
				"{val}", val,
				"{modify}",tplgetmodify,
			}...).Replace(tplset)
		}
	}
	_, _ = file.WriteString(context)
}
func strFirstToUpper(str string) string {
	if len(str) < 1 {
		return ""
	}
	strArry := []rune(str)
	if strArry[0] >= 97 && strArry[0] <= 122 {
		strArry[0] -= 32
	}
	return string(strArry)
}

func switchPtrAndVal(expr ast.Expr) (string,bool){
	var (
		val string
		ptr bool
	)
	switch v := expr.(type) {
	case *ast.Ident:
		val = v.Name
	case *ast.StarExpr:
		val = "*" + v.X.(*ast.Ident).Name
		ptr = true
	default:
		return "",false
	}
	return val,ptr
}